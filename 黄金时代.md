# 黄金时代
> 服务器源代码 2025.11.15
>
> 这是一个玩家驱动的市场经济系统，允许玩家创建订单、浏览市场、完成交易

```js
/*
    备注：如果你要拿走此代码，请修改owner和admins变量的内容。
    死神永生色系：
        #ac73ff #aca8ff #9de5ff #d5fdff #ff4d4d  #ff8364  #fdb87d  #ffe8d5 #d7fbe8 #9df3c4 #62d2a2  #1fab89
*/
api.broadcastMessage("这是测试信息:世界指令修改完毕");
const owner = 'The_DarkForest';
var admins = ['The_DarkForest', 'CN171_21', 'Silverpiston___', '__DUNE__', 'byto10'];
var posForType0 = 225;
var posForType1 = 0;
// 下划线替换函数（保持一致性）
const normalizeItemName = (name) => {
    if (!name) return "";
    return name.replace(/_/g, " ");
};

function write(data, type, pos, cover) {
    if (cover == 0) {
        while (api.getBlock(pos, -500 - type, 0) != "Air") {
            pos++;
        }
    }
    api.setBlock(pos, -500 - type, 0, "Bedrock");
    for (let i = 0; i < data.length; i++) {
        var id = data[i].charCodeAt(0);
        if (id >= 0 && id <= 127) {
            var block = api.blockIdToBlockName(id + 5);
            api.setBlock(pos, -500 - type, i + 1, block);
        } else {
            api.setBlock(pos, -500 - type, i + 1, "Beacon");
        }
    }
    api.setBlock(pos, -500 - type, data.length + 1, "Bedrock");
    if(type === 0) {
        posForType0 = pos; // 更新posForType0
    }
    if(type === 1) {
        posForType1 = pos; // 更新posForType1
    }
    return pos;
}

function read(type, pos) {
    if (api.getBlock(pos, -500 - type, 0) !== "Bedrock") {
        return "";
    }
    let data = "";
    let i = 1;
    while (true) {
        const block = api.getBlock(pos, -500 - type, i);
        if (block === "Bedrock") break;
        if (block === "Beacon") {
            data += "<?>";
        } else {
            const blockId = api.blockNameToBlockId(block);
            if (blockId !== null && blockId >= 5) {
                data += String.fromCharCode(blockId - 5);
            } else {
                data += "<?>";
            }
        }
        i++;
    }
    return data;
}



// 修复ID处理逻辑
function getOrderById(id) {
    let data = read(1, id);
    if (data.startsWith("!")) {
        return null; // 忽略已完成的订单
    }
    let parts = data.split(" ");
    if (parts.length < 5) {
        return null; // 数据不完整
    }
    return {
        name: parts[0],
        tosell: normalizeItemName(parts[1]),
        amount: parseInt(parts[2]),
        tobuy: normalizeItemName(parts[3]),
        price: parseInt(parts[4])
    };
}

/*硬盘分配:
[type] = 0:玩家数据 1:订单队列
*/
onPlayerJoin = (playerId) => {
    user = api.getEntityName(playerId);
    wenzi = user + '大蛇，欢迎来到黄金时代！';
    api.broadcastMessage([{ str: "", style: { color: "#c3c3c3" } }, { str: wenzi, style: { color: "#71c9ce" } }]);
    wenzi = user + ', Welcome to The Golden Era!';
    api.broadcastMessage([{ str: "", style: { color: "#c3c3c3" } }, { str: wenzi, style: { color: "#a6e3e9" } }]);
    playnumber = api.getNumPlayers();
    api.broadcastMessage('人数为' + playnumber, { color: "#adf7d1" });
    api.sendMessage(playerId, `你好我是服主\n欢迎你来到我的服务器, 在这里, 你可以买卖交易, 你可以输入#help 查询指令. \n不要有隔阂感服主也是人, 我很乐意和大家交流学习.\n祝您玩得开心! \nThe_DarkForest\n2025.7.12 `, { color: "#9de5ff" });
}

onPlayerLeave = (playerId, serverIsShuttingDown) => {
    user = api.getEntityName(playerId);
    write("leaved:" + user, 0, posForType0, 0);
}

const bannedItems = ["Moonstone Explosive", "Moonstone Remote Explosive", "Floor Creator", "RPG", "Fireball", "Super RPG", "Grenade Launcher", "Bouncy Bomb", "Iceball"];

onInventoryUpdated = (playerId) => {
    for (const item of bannedItems) {
        if (api.getInventoryItemAmount(playerId, item) > 0) {
            api.removeItemName(playerId, item, api.getInventoryItemAmount(playerId, item));
            api.sendMessage(playerId, `本服全服禁烟，你不能携带 ${item}`, { color: "#ff8364" });
        }
    }
}

const items = ["Iron Sword", "Iron Pickaxe", "Iron Axe", "Aspen Log", "Smooth Stone", "Glass", "Board", "Workbench", "Iron Bow", "Arrow"];
const amounts = [1, 1, 1, 249, 256, 256, 64, 8, 1, 256];

onPlayerChat = (playerId, chatMessage) => {
    const args = chatMessage.split(/\s+/);
    const cmd = args[0].toLowerCase();
    if (chatMessage[0] === '#') {
        if (cmd === "#help") {
            api.sendMessage(playerId, "可用指令：\n\
            \t#help - 显示帮助信息\n\
            \t#items - 获取有用的物品\n\
            \t#sell [ToSell] [Amount] [ToBuy] [Price] - 申请一笔交易\n\
                \t 参数说明:\n\
                \t [ToSell]\t - 出口物品名, 下划线代替空格, 字符串\n\
                \t [Amount]- 总量, 你要卖多少个ToSell, 整数\n\
                \t [toBuy]\t - 进口物品名, 下划线代替空格, 字符串\n\
                \t [Price]\t - 总价, 你要换多少个ToBuy, 整数\n\
                \t 比如出口10块煤，来换取25个木头，则可以输入 #sell Coal 10 Aspen_Log 25\n\
            \t#orders [Id] - 查看可用交易以及它们的id, 因为Bloxd资源有限, 因此本指令只能为你展示从第[Id]个订单开始的连续5个, 你可以多输入几次。\n\
            \t#buy [Id] - 输入id来进行一笔交易。注意交易时必须双方都在服务器中, 并且有足够的物品。\n", { color: "#fdb87d" });
            api.sendMessage(playerId, "by The_DarkForest", { color: "#ffe8d5" });
        }
        if (cmd === "#items") {
            for (var i = 0; i < items.length; i++) {
                if (api.getInventoryItemAmount(playerId, items[i]) === 0) {
                    api.giveItem(playerId, items[i], amounts[i]);
                }
            }
            api.sendMessage(playerId, `以获得物品`, { color: "#9df3c4" });
        }
        if (cmd === "#sell") {
            if (args.length < 5) {
                api.sendMessage(playerId, "格式错误，正确格式为 #sell [ToSell] [Amount] [ToBuy] [Price]\n\
                    \t[ToSell] - 出口物品名字, 下划线代替空格, 字符串\n\
                    \t[Amount] - 总量, 你要卖多少个ToSell, 整数\n\
                    \t[ToBuy]  - 进口物品名字, 下划线代替空格, 字符串\n\
                    \t[Price]  - 总价, 你要换多少个ToBuy, 整数\n\
                    比如出口10块煤，来换取25个木头，则可以输入 #sell Coal 10 Aspen_Log 25", { color: "#ff4d4d" });
                return false;
            }
            
            // 使用标准化函数处理物品名称
            const tosell = normalizeItemName(args[1]);
            const amount = parseInt(args[2]);
            const tobuy = normalizeItemName(args[3]);
            const price = parseInt(args[4]);
            
            // 验证物品有效性
            if (!api.getInitialItemMetadata(tosell) || !api.getInitialItemMetadata(tobuy)) {
                api.sendMessage(playerId, "错误: 无效的物品名称", { color: "#ff4d4d" });
                return false;
            }
            
            // 检查玩家库存
            const playerAmount = api.getInventoryItemAmount(playerId, tosell);
            if (playerAmount < amount) {
                api.sendMessage(playerId, `东西数量不足: 只有 ${playerAmount} 个 ${tosell}`, { color: "#ff4d4d" });
                return false;
            }
            
            // 冻结商品
            // api.removeItemName(playeId, tosell, amount);
            
            // 存储标准化名称的订单
        
            let thisid = write(`${api.getEntityName(playerId)} ${tosell} ${amount} ${tobuy} ${price}`, 1, 0, 0);
            // write(thisid, 1, -1, 1); // 报错显示thisid作为data时，长度为NaN 
            api.sendMessage(playerId, `订单已存储`, { color: "#9df3c4" });
            api.broadcastMessage(`${api.getEntityName(playerId)}创建了新的订单，欢迎通过 #orders ${thisid} 查看`, { color: "#9de5ff" });
        }
        if (cmd === "#orders") {
            if (args.length > 2) {
                api.sendMessage(playerId, "格式错误: 正确格式为 #orders [Id]\n\t[Id] - 可选参数, 从第[Id]个订单开始查看, 默认为0", { color: "#ff4d4d" });
                return false;
            }
            // orders指令有大量时间复杂度，导致经常出现interruped的问题，请你给出建议
            api.sendMessage(playerId, `本指令依赖大量调用，如果卡顿属于正常现象，请稍后再试`, { color: "#9df3c4" });
            let orders = [];
            let p = (args.length === 2 && !isNaN(parseInt(args[1]))) ? parseInt(args[1]) : (posForType1 >= 5 ? posForType1-5 : 0);
            let cnt = 0;
            if (p < 0) {
                api.sendMessage(playerId, "错误: Id不能为负数", { color: "#ff4d4d" });
                return false;
            }
            while (read(1, p) !== "" && cnt < 7) {
                if (read(1, p).startsWith("!")) {
                    p++;
                    cnt++;
                    continue;
                }
                let data = read(1, p).split(" ");
                if (data.length >= 5) {
                    orders.push({
                        id: p,
                        name: data[0],
                        tosell: normalizeItemName(data[1]), // 立即标准化名称
                        amount: parseInt(data[2]),
                        tobuy: normalizeItemName(data[3]), // 立即标准化名称
                        price: parseInt(data[4])
                    });
                    cnt++;
                }
                p++;
            }
            if (orders.length === 0) {
                api.sendMessage(playerId, "当前没有记录到任何订单, 你可以尝试: 加一个别的参数，如#orders 10; 也可以通过 #sell 创建你自己的订单. ", { color: "#ff4d4d" });
                return;
            }
            let message = "现有订单(部分)：\n";
            for (var i = 0; i < orders.length; i++) {
                let data = orders[i];
                message += `${data.id}. 用${data.price}个${data.tobuy} 换 ${data.amount}个${data.tosell} \n\t订单创建人:${data.name}\n`;
            }
            api.sendMessage(playerId, message, { color: "#adf7d1" });
            api.sendMessage(playerId, "如果有适合你的，你可以通过输入 #buy [Id] 来接单", { color: "#d7fbe8" });
            api.sendMessage(playerId, `不要尝试购买NaN个物品，因为这是早期测试时产生的bug。`, { color: "#fdb87b" });
        }
        if (cmd === "#buy") {
            if (args.length < 2) {
                api.sendMessage(playerId, "格式错误，正确格式为 #buy [OrderId]\n\t[OrderId] - 要购买的订单编号，可通过输入 #orders 查看编号\n", { color: "#ff4d4d" });
                return false;
            }
            let id = parseInt(args[1]);
            let cur = getOrderById(id);
            api.sendMessage(playerId, `正在尝试进行编号为${id}的订单交易...`, { color: "#d7fbe8" });
            const sellerId = api.getPlayerId(cur.name);
            if (!sellerId || !api.playerIsInGame(sellerId)) {
                api.sendMessage(playerId, `交易失败: ${cur.name} 不在游戏中`, { color: "#ff4d4d" });
                return false;
            }
            cur.tobuy = normalizeItemName(cur.tobuy); // 确保名称标准化
            cur.tosell = normalizeItemName(cur.tosell); // 确保名称标准化
            if (api.getInventoryItemAmount(playerId, cur.tobuy) < cur.price) {
                api.sendMessage(playerId, `交易失败: 你背包中的 ${cur.tobuy} 不够，需要 ${cur.price} 个`, { color: "#ff4d4d" });
                return false;
            }
            if (api.getInventoryItemAmount(sellerId, cur.tosell) < cur.amount) {
                api.sendMessage(playerId, `交易失败: 对方背包中的 ${cur.tosell} 不够，需要 ${cur.amount} 个`, { color: "#ff4d4d" });
                return false;
            }
            api.removeItemName(playerId, cur.tobuy, cur.price);          // 买家付款
            api.removeItemName(sellerId, cur.tosell, cur.amount);        // 卖家发货
            api.giveItem(playerId, cur.tosell, cur.amount);              // 买家收货
            api.giveItem(sellerId, cur.tobuy, cur.price);                // 卖家收款
            write(`!${cur.name} ${api.getEntityName(playerId)} ${cur.tosell} ${cur.amount} ${cur.tobuy} ${cur.price}`, 1, id, 1);
            api.sendMessage(playerId, `交易成功! 获得 ${cur.amount} 个 ${cur.tosell}`, { color: "#9df3c4" });
            api.sendMessage(sellerId, `${api.getEntityName(playerId)} 完成了你的订单，获得 ${cur.price} 个 ${cur.tobuy}`, { color: "#9df3c4" });
        }
        return false;
    }
};
```

## 代码解释 
> 由Deepseek生成

这是一个用于Bloxd游戏的**交易系统**代码，实现了玩家间的物品交易功能。让我详细解释各个部分：

### 核心功能概述

这是一个**玩家驱动的市场经济系统**，允许玩家创建订单、浏览市场、完成交易。

### 关键技术实现

#### 1. **数据存储系统**
```javascript
function write(data, type, pos, cover) {
    // 使用游戏方块作为"硬盘"存储数据
    // Bedrock作为分隔符，字符编码为方块ID
}

function read(type, pos) {
    // 从方块中读取存储的数据
}
```
- **创新点**：利用游戏方块作为持久化存储
- **编码方式**：ASCII字符 → 方块ID (+5偏移)
- **数据类型**：0=玩家数据，1=订单数据

#### 2. **订单管理系统**

**订单格式**：`玩家名 出售物品 数量 购买物品 价格`
```javascript
// 示例：玩家A用10个Coal换25个Aspen Log
"The_DarkForest Coal 10 Aspen_Log 25"
```

### 主要命令解析

#### `#help` - 帮助系统
显示完整的命令说明和交易格式。

#### `#items` - 初始物资
```javascript
const items = ["Iron Sword", "Iron Pickaxe", "Iron Axe", "Aspen Log", ...];
const amounts = [1, 1, 1, 249, 256, ...];
```
给予新玩家基础生存工具和资源。

#### `#sell` - 创建卖单
```javascript
// 示例：出售10个煤换取25个木头
#sell Coal 10 Aspen_Log 25
```
**流程**：
1. 验证参数和物品有效性
2. 检查玩家库存
3. 冻结商品（注释掉了实际扣除）
4. 写入订单数据

#### `#orders` - 浏览市场
**性能问题分析**：
```javascript
while (read(1, p) !== "" && cnt < 7) {
    // 每次read都涉及多个api.getBlock调用
    // 遍历大量位置导致API调用频繁
}
```
**问题根源**：
- 线性扫描存储位置
- 每个订单需要多次方块读取
- 没有索引或缓存机制

#### `#buy` - 完成交易
```javascript
// 交易验证逻辑
1. 检查卖家是否在线
2. 验证买家有足够支付物品
3. 验证卖家有足够出售物品
4. 执行物品交换
5. 标记订单完成
```

### 代码亮点

#### 1. **物品名称标准化**
```javascript
const normalizeItemName = (name) => {
    return name.replace(/_/g, " ");
};
```
解决用户输入不一致问题（下划线vs空格）。

#### 2. **安全机制**
```javascript
const bannedItems = ["Moonstone Explosive", "RPG", "Fireball", ...];
onInventoryUpdated = (playerId) => {
    // 自动移除违禁物品
}
```
维护服务器安全，禁止破坏性物品。

### 潜在问题和改进

### 1. **数据一致性风险**
- 订单创建后没有立即扣除物品
- 可能产生超卖问题

### 2. **存储效率**
- 线性增长的存储空间
- 没有数据压缩

### 3. **交易安全**
- 缺乏交易撤销机制
- 没有防欺诈保护

## 总结

这是一个**创意十足但性能有待优化**的交易系统：

这套系统体现了在游戏限制条件下实现复杂功能的创造力，是典型的"在沙盒中建造另一个沙盒"的范例。
