# 风云际会
> 服务器源代码 2025/11/15
> 史山，欢迎改进。为保护劳动，鼓励创新，在其他服转载请注明来源。

```js
/*
    * 本代码由The_DarkForest编写，转载请注来源
    * 原用于Bloxd服务器 风云际会 中。
    * 代码有参考死神永生服务器
*/

const purple = "#ac73ff", blue = "#aca8ff", cyan = "#9de5ff", sky = "#d5fdff", red = "#ff4d4d", orange = "#ff8364", gold = "#fdb87d", yellow = "#ffe8d5", mint = "#d7fbe8", grass = "#9df3c4", green = "#62d2a2", jungle = "#1fab89";
const owner = 'The_DarkForest';

//建造巨型楼梯相关代码
const W = 10, P = 5; // 楼梯宽度(z方向)，单阶长度(x方向)
const stx = 1000, sty = 0, stz = 1000; // 起始位置
var L = 1000;
function xz2Height(x, z) {
    if((x < stx) || (z < stz) || (z > stz+P)) return 0;
    return Math.floor((x - stx) / P)+1;
}
function getRandomX(){
    x = Math.floor(Math.random() * L);
    return stx + x + 5;
}

// 楼梯中的方块会随机消失，消失前会变色，让玩家有时间逃离此方块
// 变色目前默认 Light Blue -> Yellow -> Red，以后加更丰富的颜色
// const h2color = [["", "", ""], ["", "", ""], ["", "", ""], ["", "", ""], ["", "", ""], ["", "", ""]];

var changingBlocks = []; // 记录正在变色的方块
const ticks2Disappear = 40;
var curBlock = 0;
var T = 0;

var rank = [];
var extras = [];

tick = () => {
    T = (T + 1) % 10000;
    // 1.随机找一个楼梯上的正常方块，开始变色
    // 2.更新所有正在变色的方块
    // 3.随机找一个楼梯上的空气方块，生成一个新的正常方块
    // 如何保证每次消失和补充的数量大致相等？

    if (true) {
        for(let i = 0;i < 10;i++){
            const rx = getRandomX();
            const rz = Math.floor(Math.random() * P) + stz;
            const ry = xz2Height(rx, rz);
            if (ry > 0) {
                const blockType = api.getBlock(rx, ry, rz);
                if (blockType === 'Light Blue Concrete') {
                    changingBlocks.push({ x: rx, y: ry, z: rz, stage: 0 });
                    api.setBlock(rx, ry, rz, 'Yellow Concrete');
                }
            }
        }
    }
    for (let i = changingBlocks.length - 1; i >= 0; i--) {
        const block = changingBlocks[i];
        block.stage += 1;
        if (block.stage === Math.floor(ticks2Disappear/2)) {
            api.setBlock(block.x, block.y, block.z, 'Red Concrete');
        } else if (block.stage === ticks2Disappear) {
            api.setBlock(block.x, block.y, block.z, 'Air');
            changingBlocks.splice(i, 1);
        }
    }
    if (true) {
        for(let i = 0;i < 10;i++){
            const rx = getRandomX();
            const rz = Math.floor(Math.random() * P) + stz;
            const ry = xz2Height(rx, rz);
            const blockType = api.getBlock(rx, ry, rz);
            if (blockType === 'Air') {
                api.setBlock(rx, ry, rz, 'Light Blue Concrete');
            }
            // 如果是其他颜色，但不在变色列表中，也补充为正常方块
            else if (blockType !== 'Light Blue Concrete') {
                let isChanging = false;
                for (const b of changingBlocks) {
                    if (b.x === rx && b.y === ry && b.z === rz) {
                        isChanging = true;
                        break;
                    }
                }
                if (!isChanging) {
                    api.setBlock(rx, ry, rz, 'Light Blue Concrete');
                }
            }
        }
    }

    // 玩家相关：
    // 1.玩家排名
    // 2.掉落（y=1）后传送回起点
    // 两者均在tick中以一定间隔遍历刷新

    if (T % 20 === 0) {
        rank = [];
        const ids = api.getPlayerIds()
        for (const id of ids) {
            const pos = api.getPosition(id);
            const y = Math.floor(pos[1]);
            if (y <= 1) {
                // 如果有moonstone，传送到此x z对应的高度
                const moonstoneCount = api.getInventoryItemAmount(id, "Moonstone");
                if (moonstoneCount > 0) {
                    const rx = pos[0];
                    const rz = pos[2];
                    const ry = xz2Height(rx, rz);
                    api.setPosition(id, [rx, ry + 2, rz]);
                    api.setBlock(rx, ry, rz, "Light Blue Concrete");
                    api.removeItemName(id, "Moonstone", 1);
                    continue;
                }
                // 如果有 Diamond，传送到此x减半 z减半对应的高度的位置
                const diamondCount = api.getInventoryItemAmount(id, "Diamond");
                if (diamondCount > 0) {
                    const deathX = pos[0]; // 玩家死亡时的x坐标
                    const deathZ = pos[2];
                    const halfX = stx + (deathX - stx) / 2;
                    const ry = xz2Height(halfX, deathZ);
                    const safeX = Math.max(stx + P, halfX);
                    api.setPosition(id, [safeX, ry + 2, deathZ]);
                }
                else {
                    api.setPosition(id, [stx + 0.5, sty + 2, stz + P / 2 + 0.5]);
                }
            }
            // 在rank中插入这个玩家的名字和高度
            const name = api.getEntityName(id);
            rank.push({ name: name, height: y });
        }
        // 根据高度排序
        rank.sort((a, b) => b.height - a.height);
        var string = "高度排名：\n";
        for (var i = 0; i < rank.length; i++) {
            const playerName = rank[i].name;
            const playerHeight = rank[i].height;
            string += `${parseInt(i+1)}. ${playerName} , ${playerHeight}m\n`;
        }
        string += `\n输入 #help 查看命令列表`;
        //遍历玩家
        for (const id of ids) {
            api.setClientOption(id, "RightInfoText", [
                {str: string, style: {color: sky}}
            ]);
        }
    }

    // 奖励机制设定：
    // 首先判断玩家为Original或Extra模式，只有Extra模式享受奖励
    // 玩家可随时通过输入 #mode original 或 #mode extra 切换模式，玩家模式状态存储在extras中
    // 每100tick赠送一次礼物
    // 给第一的玩家赠送Moonstone，给第二的玩家赠送Diamond，但一个人在同一时间拥有的Moonstone或Diamond数量上限为3
    // 给位于排名中间的玩家赠送Iron Bar，数量无上限
    // 随机给一个玩家赠送Coal，数量无上限
    // Moonston:重生到上次死的地方 Diamond:重生到上次死的地方的一半 Iron Bar:传送到台阶上随机位置 Coal:有50%概率杀死自己，有50%概率传送到两倍的高度
    if (T % 1000 === 0) {
        // 按照在rank中的顺序，筛选出extras中的玩家
        const extraPlayers = [];
        for (const r of rank) {
            const p = extras.find(p => p.name === r.name);
            if (p) {
                extraPlayers.push(p);
            }
        }
        if (extraPlayers.length === 0) return;
        // 第一名（优先使用已存的 id，若不存在再尝试通过 name 查找）
        const firstPlayer = extraPlayers[0];
        const firstId = firstPlayer?.id ?? api.getPlayerId(firstPlayer?.name);
        if (firstId) {
            const firstMoonstoneCount = api.getInventoryItemAmount(firstId, "Moonstone");
            if (firstMoonstoneCount < 3) {
                api.giveItem(firstId, "Moonstone", 1, {customDisplayName: "广寒宫之心", customDescription: "价值一条命(下次直接从死的地方继续"});
            }
        }
        // 第二名
        if (extraPlayers.length >= 2) {
            const secondPlayer = extraPlayers[1];
            const secondId = secondPlayer?.id ?? api.getPlayerId(secondPlayer?.name);
            if (secondId) {
                const secondDiamondCount = api.getInventoryItemAmount(secondId, "Diamond");
                if (secondDiamondCount < 3) {
                    api.giveItem(secondId, "Diamond", 1, {customDisplayName: "和田玉", customDescription: "价值半条命(下次从死前位置的一半继续"});
                }
            }
        }
        // 中间名次玩家
        const middleIndex = Math.floor(extraPlayers.length / 2);
        const middlePlayer = extraPlayers[middleIndex];
        const middleId = middlePlayer?.id ?? api.getPlayerId(middlePlayer?.name);
        if (middleId) {
            api.giveItem(middleId, "Iron Bar", 1, {customDisplayName: "末日之战战舰碎片", customDescription: "输入#ib使用，使用的时候传送到梯子上随机位置"});
        }
        // 随机玩家
        const randomIndex = Math.floor(Math.random() * extraPlayers.length);
        const randomPlayer = extraPlayers[randomIndex];
        const randomId = randomPlayer?.id ?? api.getPlayerId(randomPlayer?.name);
        if (randomId) {
            api.giveItem(randomId, "Coal", 1, {customDisplayName: "薛定谔玄武岩", customDescription: "输入#c使用，50%概率杀死自己，50%概率传送到两倍高度"});
        }
    }
    L = Math.max(L, rank[0]?.height*P + 100 || 300);
}

onPlayerJoin = (playerId) => {
    user = api.getEntityName(playerId);
    api.broadcastMessage((user + ' 大蛇，欢迎光临'), { color: "#daf4f5" });
    api.broadcastMessage((user + ', welcome to Bloxd'), { color: "#c4dce0" });
    api.broadcastMessage('人数为' + api.getNumPlayers(), { color: "#abcecf" });
    api.setClientOption(playerId,'skyBox','interstellar')
    api.sendMessage(playerId, "一直往前走。阶梯长达理论上无限长。路上的方块会随机变红，然后消失。请不要掉下去。\n\n输入 #x 开启奖励\n输入 #help 查看帮助。", { color: grass})
    api.sendMessage(playerId, "Keep going forward. The stair is very long. The blocks on the way will randomly turn red and then disappear. Please don't fall down.", { color: mint})
}

// 当玩家离开时清理 extras，避免存留已下线玩家的 name 导致通过 name 查 id 返回 null
onPlayerLeave = (playerId) => {
    extras = extras.filter(p => p.id !== playerId);
}

onPlayerChat = (playerId, chatMessage) => {
    const args = chatMessage.split(/\s+/);
    const cmd = args[0].toLowerCase();
    if (cmd === "#mode" && args[1] === "original" || cmd === "#o") {
        // 如果在extras中，移除该玩家（使用 id 作为唯一标识以避免 name 与离线问题）
        extras = extras.filter(p => p.id !== playerId);
        api.sendMessage(playerId, "你已切换到Original模式，将不享受奖励。", { color: orange });
        api.clearInventory(playerId);
    }
    else if (cmd === "#mode" && args[1] === "extra" || cmd === "#x") {
        // 设置玩家为Extra模式（存 id 与 name）
        const playerName = api.getEntityName(playerId);
        if (!extras.find(p => p.id === playerId)) {
            extras.push({ id: playerId, name: playerName });
        }
        api.sendMessage(playerId, "你已切换到Extra模式，将享受奖励。", { color: grass });
    }
    else if (cmd === "#view" && args[1] === "players") {
        //所有玩家和此时的模式
        let message = "当前所有玩家模式：\n";
        const ids = api.getPlayerIds();
        for (const id of ids) {
            const name = api.getEntityName(id);
            const mode = extras.find(p => p.id === id) ? "Extra" : "Original";
            message += `${name} : ${mode}\n`;
        }
        api.sendMessage(playerId, message, { color: sky } );
    }
    else if (cmd === "#use" && args[1] === "coal" || cmd === "#c") {
        if (api.getInventoryItemAmount(playerId, "Coal") <= 0) {
            api.sendMessage(playerId, "你没有Coal，无法使用。", { color: red });
            return;
        }
        const chance = Math.random();
        if (chance < 0.5) {
            api.killLifeform(playerId, { lifeformId: playerId, withItem: "Coal" })
            api.sendMessage(playerId, "你使用了Coal，但不幸被杀死了。", { color: red });
        }
        else {
            const pos = api.getPosition(playerId);
            const newX = (pos[0]-stx)*2+stx;
            const newY = xz2Height(newX, pos[2]) + 2;;
            api.setPosition(playerId, [newX, newY, pos[2]]);
            if(api.getBlock(newX, newY-1, pos[2]) === 'Air'){
                api.setBlock(newX, newY-1, pos[2], "Light Blue Concrete");
            }
            api.sendMessage(playerId, "你使用了Coal，传送到了两倍的高度。", { color: mint });
        }
        api.removeItemName(playerId, "Coal", 1)
    }
    else if (cmd === "#use" && args[1] === "ironbar" || cmd === "#ib") {
        if (api.getInventoryItemAmount(playerId, "Iron Bar") <= 0) {
            api.sendMessage(playerId, "你没有Iron Bar，无法使用。", { color: red });
            return;
        }
        const rx = getRandomX() + 0.5;
        const rz = Math.floor(Math.random() * P) + stz + 0.5;
        const ry = xz2Height(rx, rz) + 1;
        api.setPosition(playerId, [rx, ry, rz]);
        api.sendMessage(playerId, "你使用了Iron Bar，传送到了台阶上的随机位置。", { color: mint });
        api.removeItemName(playerId, "Iron Bar", 1)
    }  
    else if (cmd === "#help" && args[1] === "awards") {
        let message = " =X= 奖励机制说明 =X=\n";
        message += "只有Extra模式的玩家才享受奖励，Original模式的玩家不享受奖励。\n";
        message += "每1000tick，系统会根据当前排名发放奖励：\n";
        message += "第一名获得Moonstone（上次死亡位置重生），上限3个\n";
        message += "第二名获得Diamond（上次死亡位置一半处重生），上限3个\n";
        message += "中间名次玩家获得Iron Bar（传送到台阶上随机位置），无上限\n";
        message += "随机玩家获得Coal（50%概率杀死自己，50%概率传送到两倍高度），无上限\n";
        api.sendMessage(playerId, message, { color: sky } );
    }
    else if (cmd === "#help" || cmd === "#h") {
        let message = "命令列表：\n";
        message += "#mode original - 切换到Original模式，不享受奖励，可简写 #o\n";
        message += "#mode extra - 切换到Extra模式，享受奖励，可简写 #x\n";
        message += "#view players - 查看当前所有玩家的模式\n";
        message += "#use coal - 使用Coal，有50%概率杀死自己，50%概率传送到两倍高度，可简写 #c\n";
        message += "#use ironbar - 使用Iron Bar，传送到台阶上的随机位置，可简写 #ib\n";
        message += "#help awards - 查看命令列表\n";
        api.sendMessage(playerId, message, { color: sky } );
    }

    else{
        if(chatMessage.startsWith("#")){
        api.sendMessage(playerId, "未知命令。输入 #help 查看命令列表。", { color: orange });
        }
    }

    if (chatMessage.startsWith("#")) {
        return false; // 阻止命令被其他地方处理
    }
};
```
